## 进程和线程

### 进程定义

进程狭义定义：进程就是一段程序的执行过程，比如启动的某个 app
进程广义定义：进程是资源分配的基本单位

### 进程特征：

1. 每个进程都有自己的地址空间
2. 进程是线程的容器。线程不能单独执行，必须组成进程
3. 一个程序至少有一个进程，一个进程至少有一个线程
4. 在一个进程内部，可以同时做许多件事情，比如边看视频边发弹幕

### 线程定义

是任务调度和执行的基本单元。一个进程包含多个线程

### 线程特征：

1. 一个进程至少有一个线程
2. 一个进程内部可以同时干多件事情，就需要同时运行多个子任务，这些字子任务叫做线程
3. 同一个进程中的多个线程之间可以并发执行

### 一个线程可以拥有多个协程

## 进程和线程的对比

进程可以看做独立应用，线程不能

- 资源：进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
- 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
- 调度：进程切换比线程切换的开销要大。线程是 CPU 调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

## 进程间的通信方式

1. 无名管道：半双工的通信方式，数据只能单向流动且只能在具有亲缘关系的进程间使用
2. 高级管道：将另一个程序当作一个新的进程在当前程序进程中启动，则这个进程算是当前程序的子进程
3. 有名管道：也是半双工的通信方式，但是允许没有亲缘进程之间的通信
4. 消息队列：消息队列是有消息的链表，存放在内核中，并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限的缺点
5. 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源
6. 信号：用于通知接受进程某个事件已经发生
7. 共享内存：共享内存就是映射一段能被其他进程所访问的内存。这段共享内存由一个进程创建，但是多个进程可以访问，共享内存时最快的 IPC 方式，往往与其他通信机制配合使用
8. 套接字：可用于不同机器之间的进程通信

## 进程和线程间的关系有以下四个特点：

（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。

（2）线程之间共享进程中的数据。

（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

（4）进程之间的内容相互隔离。进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。

## 浏览器渲染进程的线程有哪些

（1）GUI 渲染线程

负责渲染浏览器页面，解析 HTML、CSS，构建 DOM 树、构建 CSSOM 树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。

注意：GUI 渲染线程和 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

（2）JS 引擎线程

JS 引擎线程也称为 JS 内核，负责处理 Javascript 脚本程序，解析 Javascript 脚本，运行代码；JS 引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页中无论什么时候都只有一个 JS 引擎线程在运行 JS 程序；

注意：GUI 渲染线程与 JS 引擎线程的互斥关系，所以如果 JS 执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。

（3）时间触发线程

时间触发线程属于浏览器而不是 JS 引擎，用来控制事件循环；当 JS 引擎执行代码块如 setTimeOut 时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理；

注意：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）；

（4）定时器触发进程

定时器触发进程即 setInterval 与 setTimeout 所在线程；浏览器定时计数器并不是由 JS 引擎计数的，因为 JS 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

注意：W3C 在 HTML 标准中规定，定时器的定时时间不能小于 4ms，如果是小于 4ms，则默认为 4ms。

（5）异步 http 请求线程

XMLHttpRequest 连接后通过浏览器新开一个线程请求；
检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待 JS 引擎空闲后执行；

## 死锁

当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。
产生死锁的原因：

1. 竞争资源

产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程 P1 使用，假定 P1 已占用了打印机，若 P2 继续要求打印机打印将阻塞）
产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁

2. 进程间推进顺序非法

若 P1 保持了资源 R1，P2 保持了资源 R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当 P1 运行到 P1：Request（R2）时，将因 R2 已被 P2 占用而阻塞；当 P2 运行到 P2：Request（R1）时，也将因 R1 已被 P1 占用而阻塞，于是发生进程死锁

2.1 产生死锁的必要条件：

互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
环路等待条件：在发生死锁时，若干线程之间形成一种头尾相接的循环等待资源关系。

### 预防死锁的方法：

资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）
可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

## 32 位和 64 位

32 位操作系统针对的 32 位的 CPU 设计。64 位操作系统针对的 64 位的 CPU 设计。

- 1、运行能力不同。64 位可以一次性可以处理 8 个字节的数据量，而 32 位一次性只可以处理 4 个字节的数据量，因此 64 位比 32 位的运行能力提高了一倍。
- 2、内存寻址不同。64 位最大寻址空间为 2 的 64 次方，理论值直接达到了 16TB，而 32 位的最大寻址空间为 2 的 32 次方，为 4GB，换而言之，就是说 32 位系统的处理器最大只支持到 4G 内存，而 64 位系统最大支持的内存高达亿位数。
- 3、运行软件不同。由于 32 位和 64 位 CPU 的指令集是不同的。所以需要区分 32 位和 64 位版本的软件。
  为了保证兼容性，64 位 CPU 上也能运行老的 32 位指令。于是实际上我们可以在 64 位 CPU 上运行 32 位程序，但是反过来不行。简而言之就是 64 位的操作系统可以兼容运行 32 位的软件，反过来 32 位系统不可以运行 64 位的软件。

### 为什么 32 位操作系统最大支持内存为 4GB?

32 位操作系统地址总线是 32 位，寻址空间是 32 位。

32 位指的是:给内存编号只能编到 32 个二进制位。

32 位操作系统有 32 根地址总线，每根地址总线的状态只能是高电平或低电平，也就是只能是 1 或 0。

所以 32 位地址总线一共有 2^32 种状态。数据存储以字节 Byte 为最小单位。

32 位操作系统最大内存为 2^32Byte

2^32Byte

=2^10 _ 2^10 _ 2^10 \*2^2

=1024*1024*1024\*4Byte

=1024*1024*4k

=1024\*4MB

=4G

数据存储的最小单位是 Byte

数据传输的最小单位是 bit

## Vim 命令

<a href='https://www.runoob.com/linux/linux-vim.html'>文章</a>
<a href='https://vue3js.cn/interview/linux/vim.html#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8'>面试官系列</a>
w：将编辑的数据写入硬盘档案中
w!：若文件属性为『只读』时，强制写入该档案
q：未修改，直接退出
q!：修改过但不存储
wq：储存后离开

## Linux 命令

<a href='https://vue3js.cn/interview/linux/file.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88'>Linux 文件系统</a>
ls（英文全拼：list files）: 列出目录及文件名
cd（英文全拼：change directory）：切换目录
pwd（英文全拼：print work directory）：显示目前的目录
mkdir（英文全拼：make directory）：创建一个新的目录
rmdir（英文全拼：remove directory）：删除一个空的目录
cp（英文全拼：copy file）: 复制文件或目录
rm（英文全拼：remove）: 删除文件或目录
mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称

## Shell 命令

<a href='https://vue3js.cn/interview/linux/shell.html#%E4%BA%8C%E3%80%81%E7%A7%8D%E7%B1%BB'>面试官系列</a>
