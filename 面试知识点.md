---
typora-root-url: E:\深度学习\web前端\面试图片
---

作者：jinx丶
链接：https://www.nowcoder.com/discuss/819983
来源：牛客网

#### 知识点题目： 

###  1. HTML 

####  **\1) 语义化，标签化的作用（★）** 

1. 有利于SEO（搜索引擎优化）
2. 便于阅读，修改
3. 对盲人等不方便浏览网页的人来说比较方便

####  \2) 说说你常用的标签以及对应的作用（★★★） 

​	input button td form 

####  \3) <br>、<hr>的作用和区别（★） 

<br/>的意义是回车换行，<hr/>的意义是下划线，分隔的作用，<img/>的意义是图片分隔  <br/>是块状元素 <img/>是内联块状元素

####  \4) 说说你知道的空格标记( 等)（★） 

![image-20220322203712153](.\typora-user-images\image-20220322203712153.png)

####  \5) 各种外部文件的引用方式（★★） 

​	link  @import  import   require

####  \6) <meta>、!DOCTYPE的作用（★★） 

​      [meta标签的作用及整理_阿Q虾米的博客-CSDN博客_meta标签](https://blog.csdn.net/yc123h/article/details/51356143)

​     **meta 标签提供关于 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器如何显示内容或重新加载页面，搜索引擎（关键词）设置，或其他 web 服务**

####  \7) readonly和disabled的区别（★★★） 

**`disabled`**属性阻止对元素的一切操作，例如获取焦点，点击事件等等。
**`readonly`**属性只是将元素设置为只读，其他操作正常,只读字段是不能修改的。不过，用户仍然可以使用 tab 键切换到该字段，还可以选中或拷贝其文本。

**`disabled`**属性可以让表单元素的值无法被提交。
**`readonly`**属性则不影响提交问题。

####  \8) audio video的属性和使用（★★★） 

####  \9) frame、iframe的使用和区别（★） 

（1）frame不能脱离frameSet单独使用，iframe可以；h5已经不支持frame

（2）frame不能放在body中；

（3）嵌套在frameSet中的iframe必需放在body中；

（4）frame的高度只能通过frameSet控制；iframe可以自己控制，不能通过frameSet控制

**都会页面阻塞**

###  2. CSS 

####  \1) link为什么要放在body前（★★★） 

​			将link放在head里是规范的一部分。另外，link里的css会并行请求和解析，这样加载HMLT内容时，页面会被逐步渲染。如果将	link放到body标签后，会造成HTML加载完成后才请求css资源，造成页面白屏。

####  \2) 动画有关属性的使用、怎么定义逐帧动画（★★★） 

![image-20220322171843909](.\typora-user-images\image-20220322171843909.png)

​	![image-20220322195347937](.\typora-user-images\image-20220322195347937.png)

####  **\3) 块级、行内元素分别有哪些，区别是什么，怎么修改呈现方式（★★★★）** 

​      块级元素display: block / table  特点:独占一行，不管内容的长度
​      div h1(hx) p ul li table form
​      行内元素display: inline / inline-block
​      特点:不会独占一行，会紧跟着排列，直到没有足够的空间
​      span strong label a img input select textarea iframe

####  **\4) 盒子模型和box-sizing（★★★★★）** 

盒模型有**border-box**和**content-box**两种，默认是content-box

1. content-box: 设置的宽度就是内容宽度，整个盒子的宽度还要加上padding、border
2. border-box: 设置的宽度就是内容宽度+padding+border，因此内容宽度的实际大小要减去border和padding

​	 .box {

   width: 200px;

   border: 1px solid #000;

   margin: 10px;

   padding: 10px;

   box-sizing: border-box;

   /* 

   box-sizing: content-box;默认 盒子宽度=width+2*padding+2*border=222 内容区域200

   box-sizing: border-box; 盒子宽度=200 内容区域是200-2*border-2*padding=178

   document.querySelector(".box").offsetWidth */

  }

####  **\5) BFC、IFC、浮动、清除浮动（★★★★★）** 

IFC 中的盒子与 BFC 中的不同的是，它们可以水平依次放置。

#####  BFC

​	Block formatting context 块级格式化上下文
**​	形成独立的渲染区域**
**​	内部元素的渲染不会影响外界**

形成BFC常见的条件

​	1.html标签是BFC盒子

​	2.浮动元素是BFC盒子

​	3.行内块元素是BFC盒子

​	4.绝对定位元素 position是absolute或者fixed

​	5.overflow 不是 visible

​    6.flex元素

应用场景：**清除浮动  解决margin塌陷** 等...

![image-20220322164720864](.\typora-user-images\image-20220322164720864.png)

![image-20220322163433628](.\typora-user-images\image-20220322163433628.png)

![image-20220322164325720](.\typora-user-images\image-20220322164325720.png)

####  **\6) margin塌陷（重叠、合并）（★★★）** 

​     两个相邻的元素，分别设置margin，它们的间距不是两个margin的和，而是由较大的 margin决定 

​	margin合并 div之间的距离会取 margin-top 和margin-bottom 之间的最大值

​	**父子关系盒子：子盒子设置margin后，父盒子一起移动**

​	解决方法：

​	（1）**为父盒子设置border**，为外层添加border后父子盒子就不是真正意义上的贴合；

​	（2）**为父盒子设定padding值，**抵消掉子元素设置margin值的方式；

​	（3）**为父盒子添加overflow：hidden**；

​	（4）**为父盒子添加position：fixed；**

​	（5）**为父盒子添加 display：table；**

​	（6）**利用伪元素给子元素的前面添加一个空元素。**

##### 	margin 负值

1. top & left: 元素向上 or 向左拖拽
2. bottom & right: 元素本身不变，下边元素上移 or 右边元素左移

####  \7) flex、grid布局（★★★★★）

#####  flex布局

##### 	flex常用语法

##### 	父级容器相关

| 属性名          | 内容               | 作用                                   |
| --------------- | ------------------ | -------------------------------------- |
| flex-direction  | 主轴方向           | 水平 or 垂直                           |
| justify-content | 主轴上的对齐方式   | 开始对齐，结束对齐，居中对齐，两端对齐 |
| align-items     | 交叉轴上的对齐方式 | 开始对齐、结束对齐、居中对齐           |
| flex-wrap       | 是否换行           |                                        |

##### 	子元素相关

​	align-self: 子元素在交叉轴上的对齐方式，可以覆盖align-items

####  \8) 隐藏元素的方法，各自的区别(display/visiablity/opacity)（★★★★） 

**display:none**

设置元素的display为none是最常用的隐藏元素的方法。

```
1 .hide {
2     display:none;
3 }
```

将元素设置为display:none后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。

**visibility:hidden**

设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和display:none的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。

```
1 .hidden{
2     visibility:hidden
3 }
```

visibility:hidden适用于那些元素隐藏后不希望页面布局会发生变化的场景

**opacity:0**

opacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。

```
1 .transparent {
2     opacity:0;
3 }
```

这种方法和visibility:hidden的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。

####  \9) position各个取值的作用和场景（★★★★） 

##### absolute 和 relative

​	子绝父相

1. **relative定位 相对于 自身 定位**

2. **absolute 定位  元素会被移出正常文档流 相对于最近的一层已定位祖先元素 定位 如果元素没有已定位的祖先元素，那么它的位置相对于*最初的包含块***
   **定位元素 relative absolute fixed 或 document**
   
3. **fixed定位，元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。`fixed` 属性会创建新的层叠上下文。当元素祖先的 `transform`, `perspective` 或 `filter` 属性非 `none` 时，容器由视口改为该祖先。**

4. **static定位为默认的定位**，**该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 `top`, `right`, `bottom`, `left` 和 `z-index `属性无效。**

5. **sticky粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。**例如：

   ```
   #one { position: sticky; top: 10px; }
   ```

   **在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。**

####  **\10) link @import引入的区别（★★★）** 

1. **引入的内容不同**

   link 除了引用样式文件，还可以引用图片等资源文件，而 @import 只引用样式文件

2. **加载顺序不同**

   link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载

3. **兼容性不同**

   link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持

4. **对 JS 的支持不同**

   link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持

####  \11) 伪类，伪元素的使用和区别（★★★★） 

1. 伪类本质上是为了**弥补**常规CSS**选择器的不足**，以便获取到更多信息；

2. 伪元素本质上是创建了一个**有内容的虚拟容器**；

3. CSS3中伪类和伪元素的语法不同；  伪类 :link :hover     伪元素 ::before  ::after

4. 可以同时使用多个伪类，而只能同时使用一个伪元素；

5. 其中伪类和伪元素的根本区别在于：它们是否创造了**新**的元素,,  这个新创造的元素就叫 "伪无素" 。

   **伪元素/伪对象：不存于在DOM文档中，是虚拟的元素，是创建新元素。** 这个新元素(伪元素) 是某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中.

　　 **伪类：存在DOM文档中，(无标签,找不到, 只有符合触发条件时才能看到 ),** 逻辑上存在但在文档树中却无须标识的“幽灵”分类。

　6. 因为伪类是类似于添加类所以可以是多个，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾 

　7.  W3C中对于二者应用的描述(描述太模糊, 不容易理解)：

- - **伪类：用于向某些选择器添加特殊的效果**
  - **伪元素：用于将特殊的效果添加到某些选择器(标签**

####  \12) 选择器优先级（★★★★★） 

不同级别：!important > 内联样式 > ID选择器 > 类选择器（属性选择器、伪类选择器）> 元素选择器（伪元素选择器）> 通配符选择器 

![img](https://img-blog.csdn.net/20180527004805952)

同一级别 

（1）同一级别中后写的会覆盖先写的样式

（2）同一级别css引入方式不同，优先级不同

排序：内联（行内）样式 > 内部样式表 > 外部样式表 > 导入样式（@import）

####  \13) 水平、垂直居中方法（★★★★★） 

#####  	1 水平对齐

​	**行内元素：text-align: center**

​	**块级元素：margin: 0 auto**

​    **绝对定位元素：left: 50%**

​	 							**margin-left: -width/2 ( 自身宽度一半的负值)****

##### 	2 垂直居中

​	 行内元素：line-height:父盒子的height

 	绝对定位元素： （1）top:50% left:50%  margin-top : -height/2(自身高度一半的负值)

​							 （2）top:50% left:50% transform:translate(-50%,-50%) css3特有

​							 （3）top：0 left：0 bottom：0 right：0  margin：auto 低版本兼容浏览器

```
//使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要**考虑兼容的问题**，该方法在移动端用的较多：
.parent {
    display: flex;
    justify-content:center;
    align-items:center;
}
//另外，如果父元素设置了flex布局，只需要给子元素加上`margin:auto;`就可以实现垂直居中布局
.parent{
    display:flex;
}
.child{
    margin: auto;
}

```

##### 	line-height继承时的坑

​    line-height继承，如果是百分比的话，需要先算出结果，然后再继承。

​								如果父元素line-height是1.5等类似倍数的话 子元素行高=font-size*1.5

​								如果父元素line-height是30px 则 子元素直接继承行高

##### **3 弹窗盒子居中**

```text
#TB_Window{
	position : fixed;
	left : 50%;
	top : 50%;
	max-width : 700px;
	max-height : 800px;
	transform: translate(-50%, -50%);
}
```

​	

####  \14) 自适配属性（★★★★） 

- px 绝对长度单位 像素

- em 相对长度单位，相对于父元素

- rem 相对长度单位，相对于html根元素 1rem=html根元素的字体大小 html字体大小默认是16px 则 1rem=16px

- css3中自适应布局单位VH,VW

  1.vw: 1vm等于视口宽度的1%。

  2.vh: 1vh等于视口高度的1%。

  3.vmin:选取vm和vh中最小的那个。

  4.vmax:选取vm和vh中最大的那个。

#### \15) 谷歌浏览器如何设置小于12px大小的字体(面试)

​	谷歌浏览器默认最小字体为`12px`，小于`12px`的字体它都以`12px`显示，无论`fontSize`怎么调整，字体大小都不变，如果确实要用到更小的字体，可以通过`css`属性`transform: scale();`来缩小字体。

```
.small{ 
    font-size: 12px; 
    -webkit-transform-origin-x: 0; 
    -webkit-transform-origin-y: 0; 
    -webkit-transform: scale(0.6); 
    /*这个数字0.6，是缩放比例，可以根据你自己的情况不同而不同。*/
}
```

	首先是定义字体为12px，-webkit-transform-origin-x属性是定义了x方向（水平）的基点位置，-webkit-transform-origin-y属性是定义了y方向（竖直）的基点位置；
scale(0.6)是缩放比例，最终的字体大小就是12px * 0.6 =7.2px，这就实现了字体缩放的效果，但是可能某些浏览器不兼容一些属性，所以应该再写一个font-size为10.8px，在这个要缩放的标签上添加class="small small-size"这个属性。

​     .small-size{ font-size:10.8px; }


###  3. JS 

####  \1) async和defer的区别（★★★） 

1. `<script src="script.js"></script>`

   没有 `defer` 或 `async`，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 `script` 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

2. `<script async src="script.js"></script>`

   有 `async`，加载和渲染后续文档元素的过程将和 `script.js` 的加载与执行并行进行（异步）。

3. `<script defer src="myscript.js"></script>`

   有 `defer`，加载后续文档元素的过程将和 `script.js` 的加载并行进行（异步），但是 `script.js` 的执行要在所有元素解析完成之后，`DOMContentLoaded` 事件触发之前完成。

然后从实用角度来说呢，首先把所有脚本都丢到 `</body>` 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。

 async 异步执行js代码，可能阻塞可能不阻塞， defer延迟加载，当html全部解析之后，才执行js解析

![image-20220321223718935](.\typora-user-images\image-20220321223718935.png)

![image-20220321223750191](.\typora-user-images\image-20220321223750191.png)

####  \2) 数据类型及判断方法（★★★★★） 

[【JS 进阶】你真的掌握变量和类型了吗 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903854882947080#heading-29)

判断NaN 使用isNaN(NaN)

**1 typeof**

**适用场景**

`typeof`操作符可以准确判断一个变量是否为下面几个原始类型：

```
typeof 'ConardLi'  // string
typeof 123  // number
typeof true  // boolean
typeof Symbol()  // symbol
typeof undefined  // undefined
复制代码
```

你还可以用它来判断函数类型：

```
typeof function(){}  // function
复制代码
```

**不适用场景**

当你用`typeof`来判断引用类型时似乎显得有些乏力了：

```
typeof [] // object
typeof {} // object
typeof new Date() // object
typeof /^\d*$/; // object
复制代码
```

除函数外所有的引用类型都会被判定为`object`。

另外`typeof null === 'object'`也会让人感到头痛，这是在`JavaScript`初版就流传下来的`bug`，后面由于修改会造成大量的兼容问题就一直没有被修复...

**2 instanceof**

`instanceof`操作符可以帮助我们判断引用类型具体是什么类型的对象：

```
[] instanceof Array // true
new Date() instanceof Date // true
new RegExp() instanceof RegExp // true
复制代码
```

我们先来回顾下原型链的几条规则：

- 1.所有引用类型都具有对象特性，即可以自由扩展属性
- 2.所有引用类型都具有一个`__proto__`（隐式原型）属性，是一个普通对象
- 3.所有的函数都具有`prototype`（显式原型）属性，也是一个普通对象
- 4.所有引用类型`__proto__`值指向它构造函数的`prototype`
- 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的`__proto__`中去找

`[] instanceof Array`实际上是判断`Array.prototype`是否在`[]`的原型链上。

所以，使用`instanceof`来检测数据类型，不会很准确，这不是它设计的初衷：

```
[] instanceof Object // true
function(){}  instanceof Object // true
复制代码
```

另外，使用`instanceof`也不能检测基本数据类型，所以`instanceof`并不是一个很好的选择。

**3 toString**

上面我们在拆箱操作中提到了`toString`函数，我们可以调用它实现从引用类型的转换。

> 每一个引用类型都有`toString`方法，默认情况下，`toString()`方法被每个`Object`对象继承。如果此方法在自定义对象中未被覆盖，`toString()` 返回 `"[object type]"`，其中`type`是对象的类型。

```
const obj = {};
obj.toString() // [object Object]
复制代码
```

注意，上面提到了`如果此方法在自定义对象中未被覆盖`，`toString`才会达到预想的效果，事实上，大部分引用类型比如`Array、Date、RegExp`等都重写了`toString`方法。

我们可以直接调用`Object`原型上未被覆盖的`toString()`方法，使用`call`来改变`this`指向来达到我们想要的效果。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afa4ee855cfa98~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



**4 jquery**

我们来看看`jquery`源码中如何进行类型判断：

```
var class2type = {};
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

type: function( obj ) {
	if ( obj == null ) {
		return obj + "";
	}
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[Object.prototype.toString.call(obj) ] || "object" :
		typeof obj;
}

isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
}
复制代码
```

原始类型直接使用`typeof`，引用类型使用`Object.prototype.toString.call`取得类型，借助一个`class2type`对象将字符串多余的代码过滤掉，例如`[object function]`将得到`array`，然后在后面的类型判断，如`isFunction`直接可以使用`jQuery.type(obj) === "function"`这样的判断。

####  \3) 显示转换及隐式转换（★★★） 

[js基本类型、显示转换，隐式转换 - 掘金 (juejin.cn)](https://juejin.cn/post/6949527975595360269#heading-8)

####  \4) var、let、const作用和区别（★★★★★） 

![image-20220405225217190](.\typora-user-images\image-20220405225217190.png)

![image-20220405224718737](.\typora-user-images\image-20220405224718737.png)

![image-20220405224912987](.\typora-user-images\image-20220405224912987.png)

####  \5) 作用域、作用域链、闭包（★★★★） 

- **作用域**：用于确定在何处以及如何查找变量的一套规则。
- **作用域链**：内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为**作用域链** 就近原则。
- **词法作用域**：词法作用域是**定义在词法阶段的作用域**。词法作用域是由写代码时将代码和块作用域写在哪里来决定的，因此当词法作用域处理代码是会保持作用域不变(大部分情况)。
- 词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符
- **闭包**：
- ![image-20220405203946345](.\typora-user-images\image-20220405203946345.png)

​	![image-20220405210332109](.\typora-user-images\image-20220405210332109.png)

![image-20220405211604677](.\typora-user-images\image-20220405211604677.png)

​	![image-20220405212216592](.\typora-user-images\image-20220405212216592.png)

​	**作用：**能够在函数定义的作用域外，使用函数定义作用域内的局部变量，并且不会污染全局。

​	**原理：**基于词法作用域链和垃圾回收机制，通过维持函数作用域的引用，让函数作用域可以在当前作用域外被访问到。

####  \6) 箭头函数、普通函数作用和区别（★★★★★） 

​	**（1）箭头函数比普通函数更加简洁**
​    	如果没有参数，就直接写一个空括号即可
  	  如果只有一个参数，可以省去参数括号
​    	如果有多个参数，用逗号分割
​    	如果函数体的返回值只有一句，可以省略大括号
   	 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常用的就是调用一个函数：
   	 let fn = () => void doesNotReturn()
 	**(2) 箭头函数没有自己的this**
​	 	箭头函数不会创建自己的this,所以它没有自己的this,它只会在自己作用域的上一层继承this。所以箭头函数中的this的指向在它在定	义时就确定了，之后不会改变。

​    **(3) 箭头函数继承来的this指向永远不会改变**

​    **(4) call()、apply()、bind()等方法不能改变箭头函数中的this指向** 

​    **(5) 箭头函数不能作为构造函数使用**

​    **(6) 箭头函数没有自己的arguments**

​    **(7) 箭头函数没有prototype**

​    **(8) 箭头函数不能用作Generator函数,不能使用yeild关键字**

####  \7) call、apply、bind作用和区别（★★★★★） 

![image-20220405174912728](.\typora-user-images\image-20220405174912728.png)

​	![image-20220405163304204](.\typora-user-images\image-20220405163304204.png)

![image-20220405175811712](.\typora-user-images\image-20220405175811712.png)

![image-20220405180033105](.\typora-user-images\image-20220405180033105.png)

![image-20220405183343250](.\typora-user-images\image-20220405183343250.png)![image-20220405174414977](.\typora-user-images\image-20220405174414977.png)

####  \8) New的过程（★★★★）

**`new`** 关键字会进行如下的操作：

1. 创建一个空的简单JavaScript对象（即`**{}**`）；

2. 为步骤1新创建的对象添加属性`**__proto__**`，将该属性链接至构造函数的原型对象；

3. 让 this 指向这个新的对象。

4. 如果该函数没有返回对象，则返回`**this**`。

   ```
   function newMethod(){
   	let obj={}
   	let Constructor=[].shift.call(arguments) //删除并返回参数列表arguments中第一个参数，即获得构造函数,arguments剩余参数为构造数传参  // Array.prototype.shift.call(arguments)
   	obj.__proto__=Constructor.prototype
   	let res = Constructor.apply(obj,arguments)
   	return typeof res==='object'?res:obj
   }
   ```


####  \9) 事件委托（事件代理、事件委派）（★★★） 

![image-20220322231004527](.\typora-user-images\image-20220322231004527.png)

####  \10) 事件循环（★★★★★） 

![image-20220403195250296](.\typora-user-images\image-20220403195250296.png)

![image-20220403195428677](.\typora-user-images\image-20220403195428677.png)



![image-20220403200129325](.\typora-user-images\image-20220403200129325.png)

![image-20220403200256670](.\typora-user-images\image-20220403200256670.png)

![image-20220403202441399](.\typora-user-images\image-20220403202441399.png)

![image-20220403204344991](.\typora-user-images\image-20220403204344991.png)

![image-20220403205733425](.\typora-user-images\image-20220403205733425.png)

![image-20220403210257320](.\typora-user-images\image-20220403210257320.png)

####  \11) 添加事件、事件捕获、事件冒泡（★★★★★） 

Javascript中**添加事件**的三种方式

（1）通过在标签中为对应事件添加设定值来添加事件

（2）通过元素（Element）事件属性添加事件 

（3）通过元素（Element）事件监听器添加事件

**事件捕获：**

在事件捕获阶段，事件会从 DOM 树的最外层开始，依次经过目标节点的各个父节点，并触发父节点上的事件，直至到达事件的目标节点

**事件冒泡**：****

事件冒泡正好与事件捕获相反，事件冒泡是从目标节点开始，沿父节点依次向上，并触发父节点上的事件，直至文档根节点，就像水底的气泡一样，会一直向上

JavaScript 中提供了 stopPropagation() 方法来阻止事件捕获和事件冒泡的发生，语法格式如下：

event.stopPropagation();

注意：stopPropagation() 会阻止事件捕获和事件冒泡，但是无法阻止标签的默认行为，例如点击链接任然可以打开对应网页。

可以使用 stopImmediatePropagation() 方法来阻止同一节点的同一事件的其它事件处理程序，例如为某个节点定义了多个点击事件，当事件触发时，这些事件会按定义顺序依次执行，如果其中一个事件处理程序中使用了 stopImmediatePropagation() 方法，那么剩下的事件处理程序将不再执行。

某些事件具有与之关联的默认操作，例如当您单击某个链接时，会自动跳转到指定的页面，当您单击提交按钮时，会将数据提交到服务器等。如果不想这样的默认操作发生，可以使用 preventDefault() 方法来阻止

####  \12) 垃圾回收机制（★★★★） 

垃圾回收（Garbage Collection）是一种内存自动管理机制， 垃圾回收器（Garbage Collector）可以自动回收分配给程序的已经不再使用的内存。常见的垃圾回收算法有引用计数法和标记清除法等。V8（JavaScript 引擎，提供执行 JavaScript 的运行时环境）的垃圾回收器算法主要由 Mark-Compact 和 Scavenger 构成。

![image-20220323010118560](.\typora-user-images\image-20220323010118560.png)

**内存泄漏**

​      内存泄漏是指，应当被回收的对象没有被正常回收，变成常驻老生代的对象，导致内存占用越来越高。内存泄漏会导致应用程序速度变慢、高延时、崩溃等问题。

**1.1 内存生命周期**

1. 分配：按需分配内存。
2. 使用：读写已分配的内存。
3. 释放：释放不再需要的内存。

**1.2 内存泄漏常见原因**

- 创建全局变量，且没有手动回收。
- 事件监听器 / 定时器 / 闭包(变量设置成null进行闭包的清理)等未正常清理。
- 使用 JavaScript 对象来做缓存，且不设置过期策略和对象大小控制

#### 2. Reference Counting（引用计数）

Reference Counting 是常见的垃圾回收算法，其核心思路是：将资源（比如对象）的被引用次数保存起来，当被引用次数为零时释放。该方法的局限性：当出现**循环引用**时，互相引用的对象不会被回收。

#### 3. V8 垃圾回收机制

V8 中有两个垃圾收集器：

- **副垃圾回收器，**主要负责新生代的垃圾回收。使用 Scavenger 算法主要处理**存活周期短**的对象中的可访问对象。
- **主垃圾回收器，**主要负责老生代的垃圾回收。使用 Mark-Compact（标记整理） 算法主要处理**存活周期长**的对象中的不可访问的对象。

因为新生代中存活的可访问对象占少数，老生代中的不可访问对象占少数，所以这两种回收算法配合使用十分高效。

#### 3.1 分代垃圾收集

在 V8 中，所有的 JavaScript 对象都通过**堆**来分配。V8 将其管理的堆分成两代：新生代和老生代。其中新生代又可细分为两个子代（Nursery、Intermediate）。

即新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

![image](https://user-images.githubusercontent.com/17002181/126338733-69da76cd-33f3-4d0b-9a8e-c0e67ce0a331.png)

#### 3.2 Mark-Compact（标记整理） 算法（Major GC 主垃圾回收器）

Mark-Compact 算法可以看作是 Mark-Sweep（标记清除）算法和 Cheney 复制算法的结合。该算法主要分为三个阶段：标记、清除、整理。

![image](https://user-images.githubusercontent.com/17002181/126341694-f3a454c4-4d88-4f7c-80b8-f323843eb6a3.png)

1. **标记（Mark）**

   标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

2. **清除（Sweep）**

   清除是将不可访问的对象留下的内存空间，添加到空闲链表（free list）的过程。未来为新对象分配内存时，可以从空闲链表中进行再分配。

3. **整理（Compact）**

   整理是将活动对象往内存一端移动的过程。主要解决标记清除阶段后，内存空间出现较多内存碎片时，可能导致无法分配大对象，而提前触发垃圾回收的问题。

#### 3.3 Scavenger 算法（Minor GC 副垃圾回收器）

V8 对新生代内存空间采用了 Scavenger 算法，该算法使用了 semi-space（半空间） 的设计：将堆一分为二，始终只使用一半的空间：From-Space 为使用空间，To-Space 为空闲空间。

![image](https://user-images.githubusercontent.com/17002181/126367817-b5a12c03-18ea-4eb9-8bdb-84d2fd3e8aad.png)

新生代在 From-Space 中分配对象；在垃圾回收阶段，检查并按需复制 From-Space 中的可访问对象到 To-Space 或老生代，并释放 From-Space 中的不可访问对象占用的内存空间；最后 From-Space 和 To-Space 角色互换。

####  \13) promise系列（★★★★★） 

**Promise是什么?**

```
Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态： pending(等待态)，fulfiled(成功态)，rejected(失败态) ；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。
```


![image-20220403155208616](.\typora-user-images\image-20220403155208616.png)

​	**为了解决回调地狱的问题，ES6（ECMAScript 2015）中新增了 Promise 的概念。**  

**① Promise 是一个构造函数**
	⚫ 我们可以创建 Promise 的实例 const p = new Promise()
	⚫ new 出来的 Promise 实例对象，代表一个异步操作
**② Promise.prototype 上包含一个 .then() 方法**
	⚫ 每一次 new Promise() 构造函数得到的实例对象，
	⚫ 都可以通过原型链的方式访问到 .then() 方法，例如 p.then()
**③ .then() 方法用来预先指定成功和失败的回调函数**
	⚫ p.then(成功的回调函数，失败的回调函数)
	⚫ p.then(result => { }, error => { })
	⚫ 调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的  

**如果上一个 .then() 方法中返回了一个新的 Promise 实例对象**，则可以通过下一个 .then() 继续进行处理。通
过 .then() 方法的链式调用，就解决了回调地狱的问题  

![image-20220403180905446](.\typora-user-images\image-20220403180905446.png)

![image-20220403181135921](.\typora-user-images\image-20220403181135921.png)

![image-20220403183036469](.\typora-user-images\image-20220403183036469.png)

####  \14) 深拷贝、浅拷贝（★★★★★） 

[浅拷贝与深拷贝 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904197595332622)

**浅拷贝**是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。

**深拷贝**是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**。

**浅拷贝方法**

**1.Object.assign()**

Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。

**2.函数库lodash的_.clone方法**

该函数库也有提供_.clone用来做 Shallow Copy,后面我们会再介绍利用这个库实现深拷贝。

**3.展开运算符...**

展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。

```
let obj1 = { name: 'Kobe', address:{x:100,y:100}}
let obj2= {... obj1}
复制代码
```

**4.Array.prototype.concat()**

```
let arr = [1, 3, {
    username: 'kobe'
    }];
let arr2 = arr.concat();    
复制代码
```

**5.Array.prototype.slice()**

```
let arr = [1, 3, {
    username: ' kobe'
    }];
let arr3 = arr.slice();
```

**深拷贝的实现方式**

**1.JSON.parse(JSON.stringify())**

```
let arr = [1, 3, {
    username: ' kobe'
}];
let arr4 = JSON.parse(JSON.stringify(arr));
```

这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。

**这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则**，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。

**2.函数库lodash的_.cloneDeep方法**

```
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
复制代码
```

**3.jQuery.extend()方法**

jquery 有提供一個`$.extend`可以用来做 Deep Copy

```
$.extend(deepCopy, target, object1, [objectN])//第一个参数为true,就是深拷贝
复制代码
var $ = require('jquery');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
复制代码
```

**4.手写递归方法**

递归方法实现深度克隆原理：**遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝**。

####  \15) 图片懒加载、路由懒加载（★★★） 

[路由懒加载和图片懒加载_IE_Oxygen2.0的博客-CSDN博客_路由懒加载和图片懒加载](https://blog.csdn.net/weixin_42713144/article/details/120296997)

[性能优化-懒加载（图片 组件 路由） - 肥晨 - 博客园 (cnblogs.com)](https://www.cnblogs.com/naitang/p/14812772.html)

####  \16) 节流、防抖（★★★★） 

![image-20220407232336179](.\typora-user-images\image-20220407232336179.png)

####  \17) 数组方法解析，遍历数组、对象，for in for of的区别（★★★★★） 

  **map和foreach有什么区别**

​	foreach()方法会针对每一个元素执行提供得函数,该方法没有返回值,是否会改变原数组取决与数组元素的类型是基本类型还是引用类型；
​	map()方法不会改变原数组的值,返回一个新数组,新数组中的值为原数组调用函数处理之后的值：

![image-20220405171805402](.\typora-user-images\image-20220405171805402.png)

![image-20220405171838226](.\typora-user-images\image-20220405171838226.png)

![image-20220405171942642](.\typora-user-images\image-20220405171942642.png)

![image-20220405173813520](.\typora-user-images\image-20220405173813520.png)

####  \18) arguments、rest、展开表达式（★★） 

![image-20220405225425441](.\typora-user-images\image-20220405225425441.png)

![image-20220405225550076](.\typora-user-images\image-20220405225550076.png)

####  \19) 原型链、class继承（★★★★） 

构造函数方法存在**浪费内存**的问题。构造函数通过原型分配的函数是所有对象所**共享的**。JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。

我们可以把那些**不变的方法**，**直接定义在 prototype 对象上**，这样所有对象的实例就可以共享这些方法。

![image-20220404223022346](.\typora-user-images\image-20220404223022346.png)

![image-20220404224648042](.\typora-user-images\image-20220404224648042.png)



![image-20220404231429630](.\typora-user-images\image-20220404231429630.png)

![image-20220404232612438](.\typora-user-images\image-20220404232612438.png)

![image-20220404233010013](.\typora-user-images\image-20220404233010013.png)

![image-20220404233428366](.\typora-user-images\image-20220404233428366.png)

**原型链：**

1、当一个对象查找属性和方法时会从自身查找,如果查找不到则会通过__proto__指向被实例化的构造函数的prototype     

 2、隐式原型也是一个对象,是指向我们构造函数的原型   

 3  、除了最顶层的Object对象没有__proto__，其他所有的对象都有__proto__,这是隐式原型 

 4、隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链

![image-20220404202553766](.\typora-user-images\image-20220404202553766.png)



**class继承**：

​	通过**extends关键字**可以让子类继承父类的一些属性和方法。

​	**super 关键字**用于访问和调用对象父类上的函数。可以调用父类的**构造函数**，也可以调用父类的**普通函数**

super()==>指向父类的constructor                  super.say()==>调用父类的普通函数

![image-20220404211846263](.\typora-user-images\image-20220404211846263.png)

![image-20220404213037354](.\typora-user-images\image-20220404213037354.png)

**注意点：**

1.**在 ES6 中类没有变量提升**，所以必须先定义类，才能通过类实例化对象.

2.类里面的共有属性和方法一定要加this使用.

3.constructor 里面的this指向实例对象, 方法里面的this 指向这个方法的调用者

![image-20220405171132184](.\typora-user-images\image-20220405171132184.png)

####  \20) MAP、SET（★★★） 

1、Map是键值对，Set是值得集合，当然键和值可以是任何得值
2、Map可以通过get方法获取值，而Set不能因为它只有值
3、都能通过迭代器进行for...of 遍历
4、Set的值是唯一的可以做数组去重，而Map由于没有格式限制，可以做数据存储

####  \21) Arraybuffer，Blob等二进制处理（★★★） 

####  \22) proxy，reflect的使用（★★） 

####  \23) AJAX、axios、fetch等的使用（★★★★★） 

​		**封装axios:**[axios怎么封装，才能提升效率？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUyMTMxMTc1Ng==&mid=2247483802&idx=1&sn=1b31b7310c2c8d19ee86df22469442e4&chksm=f9dc42f9ceabcbefa34e2300f53c02dbee59b49020058be129ca403d36aa7d371d1d2d45393d&mpshare=1&scene=23&srcid=&sharer_sharetime=1587641354860&sharer_shareid=5de769e396b702376521b4a2994023c8#rd)

####  \24) sessionStorage、localstorage，前端存储（★★★★） 

​       **localStorage:**以键值对的方式存储 储存时间没有限制 永不失效 除非自己删除记录
​       **sessionStorage：**当页面关闭后被清理与其他相比不能同源窗口共享 是会话级别的存储方式
**​       cookies** **：**数据不能超过4k 同时因为每次http请求都会携带cookie 所有cookie只适合保存很小的数据 如会话标识

​						cookie是不同源的，有跨域问题

 \25) web worker，serverless worker、postmessage（★） 

 \26) canvas（★★） 

#### \27)执行上下文   执行上下文对象 变量函数提升

​	执行上下文(execute context) EC

​		 理解：代码执行的环境 

​		 时机：代码正式执行之前会进入到执行环境

​		 工作：

​			**1.创建变量对象：**

​				1）变量    2）函数及函数的参数     3）全局：window     4）局部： 抽象的但是确实存在

​			**2.确认this的指向：**

​				1）全局：this--->window

​				2）局部：this--->调用其的对象

​			**3.创建作用域链 ：**

​				父级作用域链 ＋ 当前的变量对象

​			4.扩展：

```
ECObj = { 
	变量对象：{ 变量 ，函数， 函数的形参}
	scopeChain：父级作用域链 + 当前的变量对象，
	this：{window || 调用其的对象}
}				
```

![image-20220503213501005](.\typora-user-images\image-20220503213501005.png)		![image-20220503215346978](.\typora-user-images\image-20220503215346978.png)

```
相当于执行了以下操作
function f1(){
	var a;  //其中var a=b=c=9 ===> var a=9; b=9; c=9; b和c前面没声明 可以看作全局变量
	a=b=c=9
	console.log(a) //9
	console.log(b) //9
	console.log(c) //9
}
f1()
console.log(c) //9
console.log(b) //9
console.log(a) //报错 a未定义
```

#### \28) this的指向

​	当函数作为对象的方法调用时，函数中的 this 就是该对象； 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window； 嵌套函数中的 this 不会继承外层函数的 this 值。 最后，我们还提了一下箭头函数，因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this

#### \29)说一下slice splice split 的区别?

```
// slice(start,[end])
// slice(start,[end])方法：该方法是对数组进行部分截取，该方法返回一个新数组
// 参数start是截取的开始数组索引，end参数等于你要取的最后一个字符的位置值加上1（可选）。
// 包含了源函数从start到 end 所指定的元素，但是不包括end元素，比如a.slice(0,3)；
// 如果出现负数就把负数与长度相加后再划分。
// slice中的负数的绝对值若大于数组长度就会显示所有数组
// 若参数只有一个，并且参数大于length，则为空。
// 如果结束位置小于起始位置，则返回空数组
// 返回的个数是end-start的个数
// 不会改变原数组

// splice(start,deletecount,item)
// start：起始位置
// deletecount：删除位数
// item：替换的item
// 返回值为被删除的字符串
// 如果有额外的参数，那么item会插入到被移除元素的位置上。
// splice:移除，splice方法从array中移除一个或多个数组，并用新的item替换它们。

// split(字符串)
// string.split(separator,limit)：split方法把这个string分割成片段来创建一个字符串数组。
// 可选参数limit可以限制被分割的片段数量。
// separator参数可以是一个字符串或一个正则表达式。
// 如果separator是一个空字符，会返回一个单字符的数组，不会改变原数组。
var a="0123456";  
var b=a.split("",3);  
console.log(b);//b=["0","1","2"]
// 注意：String.split() 执行的操作与 Array.join 执行的操作是相反的。


```

#### \30) 说一下怎么把类数组转换为数组?

```
//通过call调用数组的slice方法来实现转换
Array.prototype.slice.call(arrayLike)

//通过call调用数组的splice方法来实现转换
Array.prototype.splice.call(arrayLike,0)

//通过apply调用数组的concat方法来实现转换
Array.prototype.concat.apply([],arrayLike)

//通过Array.from方法来实现转换
Array.from(arrayLike)
```

#### \31) Swiper原理设计

在html ，css 已经写好的情况下。最主要的就是js的功能问题了。轮播图的功能步骤如下：

     1.先让图片轮播起来。基本就是写一个 play函数里面加定时器，每次使图片的index对象加一，当index大于最大值时，设置index等于第 一张图片.这样轮播图就动起来了。
    
    2. 轮播图动起来基本就是只显示一张图片隐藏其他的图片。我上面使用的是opacity 。
    
    3. 图片下面的按钮。主要就是使下面的按钮与上面的图片一一对应。然后点击下面的按钮显示对应的图片。
    
     4. 左右的上一张和下一张按钮。点击左边的上一张按钮图片向前显示，实现原理就是使 index 对象减一。点击左边的下一张按钮图片向后显示，实现原理就是使 index 对象加一。 
    
    5. 对应上一张和下一张连续点击的问题就是给这两个按钮加上延时器。
    
    6. 当鼠标放在轮播图区域时停止轮播，实现原理就是清除定时器，离开开始轮播就是加上定时器。

###  4. Vue(楼主主要使用的是Vue) 

#### Vue 的工作流：[Deep Dive with Evan You 笔记 | Wiidede's blog](https://wiidede.github.io/deep-dive-with-evan-you-note/#_1-intro)

- 将 template 编译成 render function；
- render function 会生成虚拟 DOM，也就是 vNode；
- vNode 经过 Vue 的处理就可以生成真实的 DOM；
- 当数据变化，就生成新的 vNode，与旧的 vNode 进行对比（patch 阶段），将有变化的地方反应到真的的 DOM 上。

#### 	Vue有3个核心模块：

  1. **响应式模块(Reactivity Module)**

     将数据做响应式处理；

  2. **编译器模块(Compiler Module)**

     将 template 编译成 render function；

     时机：运行时在浏览器中发生、构建Vue项目时更常见

  3. **渲染模块(Renderer Module)**

     在网页渲染组件的三个不同阶段：

     ​	渲染阶段(Render Phase）：调用render函数生成一个虚拟DOM节点

     ​	挂载阶段(Mount Phase)：使用虚拟DOM节点并调用DOM API来创建网页

     ​	补丁阶段(Patch Phase)：渲染器将旧的虚拟节点和新的虚拟节点进行比较并且只更新网页变化的部分

#### **Vue 3 Template Explorer**

使用 Vue 3 Template Explorer 就可以看到 Vue 3 把模板编译成了什么样的渲染函数。

一些特性（性能优化，在编译成 render function 时给 compiler 足够的提示，告诉 compiler ，什么需要处理，什么不需要处理）（这也是为什么写 template 比直接写 render 更高效的原因）：

- 标记静态节点（对象只会在初始化的时候创建一次、diff时直接不比较）
- 标记出会动态变化的属性（只检查动态变化的属性，跳过静态的属性）
- 缓存 event （这样 v-on 就不会被标记为动态变化的属性；如果在子组件上写 v-on 事件，在 patch 阶段并不会刷新整个子组件，而 Vue 2 是会的）
- 引入 block 的概念（需要动态更新的节点会被添加到 block 上，无论这个节点有多深；v-if 会开启一个新的 block，这个 block 又被其父 block 跟踪；总的来说就是在 diff 的时候不需要在去深度遍历判断，而是从 block 记录的动态节点数组上，去遍历会变化的 vNode）
- 动态节点的标记有不同的类型（更方便的 diff）

​	

####  \1) 2.X和3.0的主要更新区别（★★★） 

​     响应式原理的改变 Vue3.x 使用Proxy取代 Vue2.x 版本的Object.defineProperty 

​    组件选项声明方式Vue3.x 使用Composition API setup 是Vue3.x新增的一个选项，他
是组件内使用Composition API 的入口
​    模板语法变化slot具名插槽语法 自定义指令 v-model 升级 
​    其它方面的更改Suspense支持Fragment(多个根节点) 和Protal (在dom其他部分渲染组建内容)组件
​    针对一些特殊的场景做了处理。基于treeshaking优化，提供了更多的内置功能。

####  \2) MVVM、MVC、MVP的区别（★★★★） 

[MVC、MVP、MVVM的区别和联系（精讲版） (biancheng.net)](http://c.biancheng.net/view/7743.html)

**MVC：**

​	Controller 是 MVC 中的 C，指控制层，在 Controller 层会接收用户所有的操作，并根据写好的代码进行相应的操作——触发 Model 层，或者触发 View 层，抑或是两者都触发。

​	需要注意：Controller 层触发 View 层时，并不会更新 View 层中的数据，View 层中的数据是通过监听 Model 层数据变化而自动更新的，与 Controller 层无关。

​	![image-20220325001855746](.\typora-user-images\image-20220325001855746.png)

 **MVC缺点：**

- MVC 框架的大部分逻辑都集中在 Controller 层，代码量也都集中在 Controller 层，这带给 Controller 层很大的压力，而已经有独立处理事件能力的 View 层却没有用到。
- 还有一个问题，就是 Controller 层和 View 层之间是一一对应的，断绝了 View 层复用的可能，因而产生了很多冗余代码。

**MVP：**

​    在 MVC 框架中，View 层可以通过访问 Model 层来更新，但在 MVP 框架中，View 层不能再直接访问 Model 层，必须通过 Presenter 层提供的接口，然后 Presenter 层再去访问 Model 层。

**MVP对比MVC优点：**

- 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。

- 其次，因为 View 层与 Model 层没有关系，所以 View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多。

  ![image-20220325002715771](.\typora-user-images\image-20220325002715771.png)

  **MVP缺点**：

  ​		因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。

  为了让 View 层和 Model 的数据始终保持一致，避免同步，MVVM 框架出现了

  **MVVM：**

  ​	VM 是 ViewModel 层，ViewModel 层把 Model 层和 View 层的数据同步自动化了，解决了 MVP 框架中数据同步比较麻烦的问题，不仅减轻了 ViewModel 层的压力，同时使得数据处理更加方便——只需告诉 View 层展示的数据是 Model 层中的哪一部分即可。

  ![image-20220325003059145](.\typora-user-images\image-20220325003059145.png)

- ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：**数据绑定**。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：**DOM 事件监听**。

**MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）**

作者：Big shark@LX
链接：https://juejin.cn/post/6961222829979697165
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

####  \3) Vue框架设计的核心思想（★★★★） 

​	数据驱动试图，双向数据绑定

####  \4) Vue-cli、Vue-router、VueX等的使用（★★★★★） 

[蛋浪博客 (eggstrom.com)](https://eggstrom.com/search/articles/vue1)

#### 	**Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?**

	有五种，分别是 State、 Getter、Mutation 、Action、 Module
		1、state => 基本数据(数据源存放地)
	    2、getters => 从基本数据派生出来的数据
	    3、mutations => 提交更改数据的方法，同步
	    4、actions => 像一个装饰器，包裹mutations，使之可以异步。
	    5、modules => 模块化Vuex
	
	1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。
	2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。
### Vuex的工作流程，以及它的作用，使用场景。

**`vuex`的工作流程：**

1、在`vue`组件里面，通过`dispatch`来触发`actions`提交修改数据的操作。

2、然后再通过`actions`的`commit`来触发`mutations`来修改数据。

3、`mutations`接收到`commit`的请求，就会自动通过`Mutate`来修改`state`（数据中心里面的数据状态）里面的数据。

4、最后由`store`触发每一个调用它的组件的更新

**`Vuex`的作用**：项目数据状态的集中管理，复杂组件(如兄弟组件、远房亲戚组件)的数据通信问题。

### Vue的路由实现：hash模式 和 history模式

前端路由实现起来其实很简单，本质就是监听 `URL` 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式

1、`hash模式:` 在浏览器中符号`#`，#以及#后面的字符称之为`hash`，用 `window.location.hash` 读取。特点：`hash`虽然在`URL`中，但不被包括在`HTTP`请求中；用来指导浏览器动作，对服务端安全无用，`hash`不会重加载页面,可以通过 `hashchange` 事件来监听到 `URL` 的变化，从而进行跳转页面。

2、`history模式：` `history`采用`HTML5`的新特性；且提供了两个新方法：`pushState()`， `replaceState()`可以对浏览器历史记录栈进行修改，以及`popState`事件的监听到状态变更

####  \5) 虚拟DOM和diff[算法]()（★★★★） 

​	虚拟 DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM 的一层抽象。

​	如果直接频繁的操作真实dom，性能会变低。

**v-for 中key的作用主要是为了高效的更新虚拟DOM** ，在vue中 默认使用**就地复用策略**，在DOM操作的时候，如果没有key**会造成选项错乱，**key只能是字符串或number。

**虚拟DOM优点：**

1. **保证性能下限：** 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
2. **无需手动操作 DOM：** 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
3. **能够更方便的跨平台操作：** 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

**缺点:**

1. **无法进行极致优化**： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
2. **首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。**

**Vue2 diff算法**

​	**本质：深度递归+双指针**

​	1.判断是否是同一个元素，不是同一个元素直接替换 

​	2.如果是同一个元素=>进行对比属性=》接着对比children=》分别有四种情况

​		1）老的有children，新的没有，直接移除

​		2）老的没有children，新的有，直接添加

​		3）如果都是文本的情况下 直接创建文本

​		4）如果都有children节点 ，则进行双指针操作，分别进行 头头、尾尾、头尾、尾头 查找后进行复用

vue3：对双指针进行了优化，采用最长递增子序列

​		

####  \6) 双向绑定原理、数据劫持、依赖搜集（★★★★★） 

**双向绑定原理（v-model）：**

v-model 只是语法糖而已

v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

- text 和 textarea 元素使用 value property 和 input 事件；
- checkbox 和 radio 使用 checked property 和 change 事件；
- select 字段将 value 作为 property 并将 change 作为事件。

> 注意:对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。

在普通标签上

```javascript
    <input v-model="sth" />  //这一行等于下一行
    <input v-bind:value="sth" v-on:input="sth = $event.target.value" />
复制代码
```

在组件上

```html
<currency-input v-model="price"></currentcy-input>
<!--上行代码是下行的语法糖
 <currency-input :value="price" @input="price = arguments[0]"></currency-input>
-->

<!-- 子组件定义 -->
Vue.component('currency-input', {
 template: `
  <span>
   <input
    ref="input"
    :value="value"
    @input="$emit('input', $event.target.value)"
   >
  </span>
 `,
 props: ['value'],
})
```

####  \7) 响应式原理（★★★★） 

 **Vue2.0 响应式数据的原理：**

整体思路是**数据劫持+观察者模式**

**对象内部**通过 **defineReactive** 方法使用 **Object.defineProperty** 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 **dep 属性**存放他所依赖的 **watcher（依赖收集）**，当属性变化后会通知自己对应的 watcher 去更新(派发更新)。



![image-20220407221456220](.\typora-user-images\image-20220407221456220.png)

![image-20220407221334658](.\typora-user-images\image-20220407221334658.png)

####  \8) $nextTick的使用（★★★★） 

![image-20220328002103912](.\typora-user-images\image-20220328002103912.png)

####  \9) 组件通信方式（★★★★★） 

​	1、父传子 2、子传父 3、eventbus 4、ref/$refs 5、$parent/$children 6、$attrs/$listeners 7、依赖注入(provide/inject)

####  \10) watch和computed的区别（★★★★） 

**// 区别**

  **computed 计算属性**：**依赖其它属性值**，并且computed的值有缓存，只有它**依赖的属性值发生改变**，下一次获取computed的值时才会重新计算**computed的值。**
  **watch 侦听器：**** **更多的是观察的作用**,无缓存性,类似与某些数据的监听回调,每当**监听的数据变化时都会执行回调进行后续操作**

**//运用场景**

  **computed 计算属性**：

  **当需要进行数值计算**,并且**依赖与其它数据时**,应该使用computed,因为可以利用computed的缓存属性,避免每次获取值时都要重新计算。

  **watch 侦听器：**

  **当需要在数据变化时执行异步或开销较大的操作时,应该使用watch,使用watch选项允许执行异步操作**（访问一个API),限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

####  \11) v-if和v-show的区别（★★★★） 

 **条件渲染指令**

1. `v-show` 的原理是：动态为元素添加或移除 `display: none` 样式，来实现元素的显示和隐藏
   + 如果要频繁的切换元素的显示状态，用 v-show 性能会更好
2. `v-if` 的原理是：每次动态创建或移除元素，实现元素的显示和隐藏
   + 如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好

#### \12) v-for和v-if的优先级(2.X和3.0的优先级不一样)（★★★） 

**2.0版本 ：**

​	**当它们处于同一节点，`v-for` 的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中。当你只想为*部分*项渲染节点时，这种优先级的机制会十分有用。**

**永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上。**

一般我们在两种常见的情况下会倾向于这样做：

- 为了过滤一个列表中的项目 (比如 `v-for="user in users" v-if="user.isActive"`)。在这种情形下，请将 `users` 替换为一个计算属性 (比如 `activeUsers`)，让其返回过滤后的列表。
- 为了避免渲染本应该被隐藏的列表 (比如 `v-for="user in users" v-if="shouldShowUsers"`)。这种情形下，请将 `v-if` 移动至容器元素上 (比如 `ul`、`ol`)。

**3.0版本：**

​	**当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量：**

```html
<!-- 这将抛出一个错误，因为“todo” property 没有在实例上定义 -->

<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```

可以把 `v-for` 移动到 `<template>` 标签中来修正：

```html
<template v-for="todo in todos" :key="todo.name">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```

#### \13)生命周期

**选项式 API 的生命周期选项和组合式 API 之间的映射**

- `beforeCreate` -> 使用 `setup()`
- `created` -> 使用 `setup()`
- `beforeMount` -> `onBeforeMount`
- `mounted` -> `onMounted`
- `beforeUpdate` -> `onBeforeUpdate`
- `updated` -> `onUpdated`
- `beforeUnmount` -> `onBeforeUnmount`
- `unmounted` -> `onUnmounted`
- `errorCaptured` -> `onErrorCaptured`
- `renderTracked` -> `onRenderTracked`
- `renderTriggered` -> `onRenderTriggered`
- **keep-alive 动态组件的生命周期 切换组件不销毁** 
- `activated` -> `onActivated`
- `deactivated` -> `onDeactivated`

#### \14) Vue如何优化首页加载

1. **首页白屏原因**

   > 主要原因是单页应用,加载资源过慢， 需要将所有需要的资源都下载到浏览器端并解析。单页面应用的html 是靠 js 生成，因为首屏需要加载很大的js文件(`app.js` `vendor.js`)，所以当网速差的时候会产生一定程度的白屏。

2. **首屏优化方法**

   1. 在路由返回内容前添加loading(骨架屏)
      - [vue-server-renderer](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Ftree%2Fdev%2Fpackages%2Fvue-server-renderer%23readme)
      - [vue-skeleton-webpack-plugin](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Flavas-project%2Fvue-skeleton-webpack-plugin)
      - [page-skeleton-webpack-plugin](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FElemeFE%2Fpage-skeleton-webpack-plugin)
   2. 使用首屏SSR + 跳转SPA方式来优化
   3. 改单页应用为多页应用,使用quicklink(单页面配合路由)技术
   4. 协议优化(**B站前端铁蛋**儿)
   5. 使用web worker
   6. 第三方资源使用cdn
   7. 优化webpackp配置
      - webpack的code-split结合vue-router做懒加载
      - wepack的contenthash模式,针对文件级别更改做缓存
   8. 图片使用webp、小图采用base64编码、雪碧图等

#### \15)如何减少白屏的时间 [如何减少白屏的时间 | HZFE - 剑指前端 Offer](http://febook.hzfe.org/awesome-interview/book3/topic-white-screen-optimization)

1. **DNS 解析**
   - **预解析** DNS 预解析的方式提前获取 IP 地址，以缩短后续请求的响应时间
   - **域名收敛** 域名收敛的目的是减少页面中域名的数量，从而减少所需的 DNS 解析次数，最终减少页面的 DNS 解析过程的耗时，加快页面加载速度。
2. **TCP 连接**
   - **预连接**    前端可以通过 `preconnect` 在请求发送前预先执行一些操作，这些操作包括 DNS 解析，TCP 握手 和 TLS 协商
3. **发送并响应请求**
   - **HTTP/2**  通过使用 HTTP/2 协议，可以依赖 HTTP/2 的**多路复用、首部压缩、二进制分帧和服务端推送**等特性，从而加快整体请求的响应速度，加快页面的渲染展示。
4. **浏览器解析页面**
   - **服务端渲染**
   - **预渲染**  前端打包时使用 prerender-spa-plugin 之类的插件进行简单的预渲染，减少页面白屏的时间
5. **加载资源并渲染页面**
   - **骨架屏**
   - **资源优化**    CDN(内容分发网络)
   - **资源预加载**
6. **请求接口，获取数据并渲染**
   - **接口预加载**
   - **接口合并**

#### \16) v-for中为什么要有key

​	key可以提高虚拟DOM的更新效率，

在vue中 默认使用**就地复用策略**，在DOM操作的时候，如果没有key**会造成选项错乱，**key只能是字符串或number。

#### \17)Vue组件data选项为什么必须是个函数而Vue的根实例则没有这种限制

​	Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的;采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。

#### \18)说一下React类组件和函数组件的区别?

```
1. 语法上的区别：
函数式组件是一个纯函数，它是需要接受props参数并且返回一个React元素就可以了。类组件是需要继承React.Component的，而且类组件需要创建render并且返回React元素，语法上来讲更复杂。
2. 调用方式
函数式组件可以直接调用，返回一个新的React元素；类组件在调用时是需要创建一个实例的，然后通过调用实例里的render方法来返回一个React元素。
3. 状态管理
函数式组件没有状态管理，类组件有状态管理。
4. 使用场景
类组件没有具体的要求。函数式组件一般是用在大型项目中来分割大组件（函数式组件不用创建实例，所有更高效），一般情况下能用函数式组件就不用类组件，提升效率。

```

#### \19)说一下前端登录的流程?

​	初次登录的时候，前端调后调的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token，和一个用户信息的值，前端拿到token，将token储存到Vuex中，然后从Vuex中把token的值存入浏览器Cookies中。把用户信息存到Vuex然后再存储到LocalStroage中,然后跳转到下一个页面，根据后端接口的要求，只要不登录就不能访问的页面需要在前端每次跳转页面师判断Cookies中是否有token，没有就跳转到登录页，有就跳转到相应的页面，我们应该再每次发送post/get请求的时候应该加入token，常用方法再项目utils/service.js中添加全局拦截器，将token的值放入请求头中 后端判断请求头中有无token，有token，就拿到token并验证token是否过期，在这里过期会返回无效的token然后有个跳回登录页面重新登录并且清除本地用户的信息。

#### \20)说一下前端权限管理怎么实现

[前端如何来做权限管理？_大唐荣华的博客-CSDN博客_前端权限管理](https://blog.csdn.net/weixin_40599109/article/details/113728974)

#### \21)vue3中watch和watchEffect的区别

watch 函数用来侦听特定的数据源，并在回调函数中执行副作用。默认情况是惰性的，也就是说仅在侦听的源数据变更时才执行回调。

```vue
watch(source, callback, [options])
```

参数说明：

- source: 可以支持 string,Object,Function,Array; 用于指定要侦听的响应式变量

- callback: 执行的回调函数

- options：支持 deep、immediate 和 flush 选项。

- 需要侦听多个数据源时， 可以进行合并， 同时侦听多个数据：

  ```vue
  watch([() => state.age, year], ([curAge, newVal], [preAge, oldVal]) => {
  console.log("新值:", curAge, "老值:", preAge); console.log("新值:", newVal,
  "老值:", oldVal); });
  ```

​	`watchEffect`会自动收集依赖, 只要指定一个回调函数。在组件初始化时， 会先执行一次来收集依赖， 然后当收集到的依赖中数据发生变化时， 就会再次执行回调函数。所以总结对比如下：

1. watchEffect 不需要手动传入依赖
2. watchEffect 会先执行一次用来自动收集依赖
3. watchEffect 无法获取到变化前的值， 只能获取变化后的值



###  5. 计算机网络及通信 

####  \1) 网络模型，各自有哪些协议，端口号是多少（★★★★★） 

​	端口号可以建立 65535个 

####  \2) 输入URL到展示页面的全过程（★★★★★） 

![img](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)

- URL 输入
- DNS 解析
- 建立 TCP 连接
- 发送 HTTP / HTTPS 请求（建立 TLS 连接）
- 服务器响应请求
- 浏览器解析渲染页面
- HTTP 请求结束，断开 TCP 连接

![image-20220321003019994](.\typora-user-images\image-20220321003019994.png)

![image-20220321003252767](.\typora-user-images\image-20220321003252767.png)

![image-20220321003331868](.\typora-user-images\image-20220321003331868.png)

####  \3) 三次握手，四次挥手（★★★★★） 

​	![image-20220321195256689](.\typora-user-images\image-20220321195256689.png)

![image-20220321195500194](.\typora-user-images\image-20220321195500194.png)

####  \4) TCP、UDP的区别，TCP怎么做到的可靠传输，UDP怎么改进实现可靠传输（★★★★） 

​	传输层

​	**TCP：面向连接的，可靠的**         可靠传输的实现：**确认机制、重传机制、滑动窗口**             三次握手-->数据传输-->四次挥手

​	**UDP：基于非连接的，数据简单封装后发送，数据之间无状态 ，性能损耗少，资源占用少，稳定性弱，速度快**

![image-20220321201639350](.\typora-user-images\image-20220321201639350.png)

TCP:使用场景：发送文件 电子邮件 浏览网页

UDP：使用场景 ：域名查询 视频通话 隧道网络（vpn，vxlan）、

- 互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。
- IP负责把数据包送达目的主机。
- UDP负责把数据包送达具体应用。
- 而TCP保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。

![img](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png)

![img](https://static001.geekbang.org/resource/image/3e/ea/3edb673a43f23d84253c52124ce447ea.png)

####  \5) HTTP状态码（★★★★） 

状态码：由3位数字组成，第一个数字定义了响应的类别

**1xx：指示消息,表示请求已接收，继续处理** 

**2xx：成功,表示请求已被成功接收，处理** 

   200 OK：客户端请求成功
   204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。
   206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容

**3xx 重定向**

​      301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。
​      302 Found：临时重定向，表示请求的资源临时搬到了其他位置
​      303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问
​      307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET
​      304 Not Modified：**表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足**。返回304时，不包含任何响应 主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有

**4xx：客户端错误**

​       400 Bad Request：客户端请求有语法错误，服务器无法理解。
​       401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
​       403 Forbidden：服务器收到请求，但是拒绝提供服务
​       404 Not Found：请求资源不存在。比如，输入了错误的url
​       415 Unsupported media type：不支持的媒体类型

**5xx：服务器端错误，服务器未能实现合法的请求。**

​      500 Internal Server Error：服务器发生不可预期的错误。
​      503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常

#### \6) HTTP1.0 1.1 2.0 3.0 HTTPS Websocket（★★★★） 

![image-20220321203715137](.\typora-user-images\image-20220321203715137.png)

HTTP是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用TCP协议，
在HTTP协议中客户端发送请求接收响应，服务端接收请求发送响应，在HTTP中数据可以被称为资源可以是HTML文档、图片、普通文本
资源是通过URL来进行定位的，URL的组成部分包括：协议+ 主机（host）+ 路径（path）+ 查询参数（query）
发送HTTP请求的内容包括：请求方式（GET\POST\PUT\HEAD）、路径（path）和查询参数、HTTP版本、Request Header请求头、Request Body请求体(POST)
接收HTTP响应包含：HTTP版本、响应状态码、Request Header响应头（包含额外的信息告诉客户端如何控制缓存和cookie），响应体（从服务端返回的数据）
**HTTP是无状态的，每一次请求都认为是从全新的客户端发来的请求，如果需要记录状态的话需要cookie和session来保持会话（实现登录和购物车等功能）**
**HTTP2和HTTP1的区别是数据通过二进制来传输不再是文本的形式、多路复用（建立连接后可以一次性发送多个HTTP请求）、压缩HTTP Header 减少负载、支持Server Push**

**在标准的HTTP中，所有的消息都是明文传输的，我们客户端和服务端交互的信息都是通过公共互联网进行传输的，由于传输的内容是明文的因此我们很容易遭到黑客的攻击，因此当我们输入一些敏感的信息时就很可能被监听获取，而这也是HTTPS（更安全的超文本传输协议）诞生的原因**
HTTPS会加密传输的数据，也就是不会以明文来传输我们的数据，HTTPS通过两个协议来保障我们的
数据安全其中一个是**SSL**，SSL的工作原理：当计算机连接到使用SSL的网站时，我们的浏览器会要求网站确认自己的身份，**服务器**会**发送**给**浏览器**它的**SSL证书的副本**，**SSL是一种小型的数字证书**，用于验证网站的身份，它的作用是让你知道你当前访问的网站是可信的，如果**检查后可信就回信给服务器,服务器发送确认作为响应**，然后一个SSL会话就展开了，之后双方就可以进行加密的数据交换了

另一个协议称为**TLS**（Transport Layer Security）运输层安全协议它是行业最新的加密协议，和SSL一样它是通过对服务端和客户端进行身份验证，并对数据加密来实现的。现在很多网站都采用了HTTPS主要是因为Google浏览器会将不具有HTTPS的网站视为不安全

#### Websockethttps://blog.csdn.net/qq_54773998/article/details/123863493

 **1 websocket的原理**

​	1）websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信。

​	2）websocket是一种全新的协议，不属于http无状态协议，协议名为"ws"

 **2 websocket与http的关系**

![img](https://img-blog.csdnimg.cn/45259e81df6b4455bdcfcad460a3a8bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb2hhbmHvvIE=,size_20,color_FFFFFF,t_70,g_se,x_16)

```
相同点：
 都是基于tcp的，都是可靠性传输协议
 都是应用层协议
```

```
不同点：
 WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息
 HTTP是单向的
 WebSocket是需要浏览器和服务器握手进行建立连接的
 而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接
联系：
 WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的

```

```
总结（总体过程）：
  首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；
  然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；
  最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。
```

**3.websocket的改进**
      一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实现了“真·长链接”，实时性优势明显。

 ![img](https://img-blog.csdnimg.cn/b4f3c4efafd24359be26dc3166569f76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb2hhbmHvvIE=,size_20,color_FFFFFF,t_70,g_se,x_16)

WebSocket有以下特点：

​     是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。
HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）

####  \7) 简单请求、复杂请求、预检请求（★★★） 

[浅析http简单请求与复杂请求 - 古兰精 - 博客园 (cnblogs.com)](https://www.cnblogs.com/goloving/p/14525157.html)

​           CORS 是目前最为广泛的解决跨域问题的方案。方案依赖服务端/后端在响应头中添加 `Access-Control-Allow-*` 头，告知浏览器端通过此请求。

​     **涉及到的端**

​      CORS 只需要服务端/后端支持即可，不涉及前端改动。

​     **具体实现方式**

​      CORS 将请求分为**简单请求（Simple Requests）**和**需预检请求（Preflighted requests）**，不同场景有不同的行为：

​       **简单请求**

​         不会触发预检请求的称为简单请求。当请求满足以下条件时就是一个简单请求：

- ​      请求方法：`GET`、`HEAD`、`POST`。
- ​      请求头：Accept、Accept-Language、Content-Language、Content-Type
- Content-Type 仅支持：`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`。

​      **需预检请求**

​        当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个 **OPTIONS** 请求，通过服务端返回的 `Access-Control-   Allow-*` 判定请求是否被允许。

CORS 引入了以下几个以 `Access-Control-Allow-*` 开头：

- `Access-Control-Allow-Origin` 表示允许的来源
- `Access-Control-Allow-Methods` 表示允许的请求方法
- `Access-Control-Allow-Headers` 表示允许的请求头
- `Access-Control-Allow-Credentials` 表示允许携带认证信息

当请求符合响应头的这些条件时，浏览器才会发送并响应正式的请求。

####  \8) get、post的特点和区别（★★★★） 

**GET：**

1.倾向向服务器获取数据
2.直接在地址后面进行拼接（请求体是空的）
3.大小限制为2KB左右
4.会被浏览器主动缓存
5.相对于POST请求不是很安全（明文发送）
6.数据格式必须是url编码格式，如果不是会被自动转成url编码格式

**POST:**
1.倾向于向服务器传递数据
2.在请求体里传递数据（地址后面没有）
3.大小理论上是没有限制（但是可以被服务器限制）
4.不会被浏览器主动缓存，可以手动设置
5.相对于GET请求比较安全（暗文发送）
6.数据格式理论上无所谓, 但是要和请求头中的 content-type 一致

[head请求是什么 - 范仁义 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Renyi-Fan/p/12563894.html#:~:text=head请求是什么 一、总结 一句话总结：,HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。 一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。 这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。)

####  \9) 同源策略、跨域处理（★★★★★） 

[浏览器跨域 | HZFE - 剑指前端 Offer](http://febook.hzfe.org/awesome-interview/book1/browser-cross-origin)

​        跨域问题的来源是浏览器为了**请求安全**而引入的基于**同源策略**的安全特性。当页面和请求的**协议**、**主机名**或**端口**不同时，浏览器判定两者不同源，即为跨域请求。需要注意的是跨域是**浏览器的限制**，服务端并不受此影响。当产生跨域时，我们可以通过 JSONP、CORS、postMessage 等方式解决。

前端常见的跨域解决方案有 CORS、反向代理（Reverse Proxy）、JSONP 等。

**JSONP（JSON with padding）：**

JSONP只能发起get请求

script 标签中的src属性没有跨域限制，客户端发送**get请求**，服务端用json返回有真实数据的js函数，客户端收到后，将json解析，执行里面的js函数得到真实数据

![image-20220423030640543](.\typora-user-images\image-20220423030640543.png)

####  \10) 各种缓存机制、CDN（★★★★） 

​      HTTP 缓存主要分为**强缓存**和**协商缓存**。

​		**强缓存**可以通过 **Expires / Cache-Control** 控制，命中强缓存时不会发起网络请求，资源直接从本地获取，浏览器显示状态码 200 from cache。

​		**协商缓存**可以通过 **Last-Modified / If-Modified-Since 和 Etag / If-None-Match** 控制，开启协商缓存时向服务器发送的请求会带上缓存标识，若命中协商缓存，服务器返回 304 Not Modified 表示浏览器可以使用本地缓存文件，否则返回 200 OK 正常返回数据。

​		**优点**

- 节省了不必要的数据传输，节省带宽。
- 减少服务端的负担，提高网站性能。
- 降低网络延迟，加快页面响应速度，增强用户体验。

​      **缺点**

- 不恰当的缓存设置可能会导致资源更新不及时，导致用户获取信息滞后。

- ##### CDN（内容分发网络）

- 1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。
  2.关键技术**：内容存储和分发技术**
  3.基本原理：广泛采用各种**缓存服务器**，将这些缓存服务器分布到用户访问相对多的地区或者网络中。当用户访问网络时利用全局负载技术将用户的访问指向距离最近的缓存服务器，由缓存服务器直接响应用户的请求（全局负载技术）

####  \11) 接口幂等性（★） 

​    [什么是接口幂等性？为什么会产生这个问题？如何保证接口幂等性？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/345428483)

 	 幂等性原本是数学上的概念，用在接口上就可以理解为：**同一个接口，多次发出同一个请求，必须保证操作只执行一次。** 调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。

​    解决办法分为两个方向，一个方向是客户端防止重复调用，一个是服务端进行校验。当然，客户端防止重复提交并不是绝对可靠的，优点是实现起来比较简单。

#### \12) cookie、session、token、jwt（★★★★★） 

JWT 的三个部分依次如下。

> - Header（头部）
> - Payload（负载）
> - Signature（签名）

Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。

> ```javascript
> {
>   "alg": "HS256",
>   "typ": "JWT"
> }
> ```

上面代码中，`alg`属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；`typ`属性表示这个令牌（token）的类型（type），JWT 令牌统一写为`JWT`。

最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。

Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。

> - iss (issuer)：签发人
> - exp (expiration time)：过期时间
> - sub (subject)：主题
> - aud (audience)：受众
> - nbf (Not Before)：生效时间
> - iat (Issued At)：签发时间
> - jti (JWT ID)：编号

除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

> ```javascript
> {
>   "sub": "1234567890",
>   "name": "John Doe",
>   "admin": true
> }
> ```

注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。

这个 JSON 对象也要使用 Base64URL 算法转成字符串。

Signature 部分是对前两部分的签名，防止数据篡改。

首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。

> ```javascript
> HMACSHA256(
>   base64UrlEncode(header) + "." +
>   base64UrlEncode(payload),
>   secret)
> ```

算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（`.`）分隔，就可以返回给用户。

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

> ```javascript
> Authorization: Bearer <token>
> ```

另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

[JSON Web Token 入门教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

#### \13）为什么很多站点第二次打开速度会很快？

如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。

那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，DNS缓存和页面资源缓存这两块数据是会被浏览器缓存的。其中，DNS缓存比较简单，它主要就是在浏览器本地把对应的IP和域名关联起来，这里就不做过多分析了。

我们重点看下浏览器资源缓存，下面是缓存处理的过程：

![img](https://static001.geekbang.org/resource/image/16/02/1670e353bf6cccc096e63e0f102ed502.png)

首先，我们看下服务器是通过什么方式让浏览器缓存数据的？

**强缓存：******Cache-Control  200ok from cache****

从上图的第一次请求可以看出，当服务器返回HTTP响应头给浏览器时，浏览器是通过响应头中的Cache-Control字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过Cache-Control中的Max-age参数来设置的，比如上图设置的缓存过期时间是2000秒。

```text
Cache-Control:Max-age=2000
```

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。

**协商缓存：******If-None-Match**** **没有更新返回304 Not modified**

但如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP请求头中带上：

```text
If-None-Match:"4f80f-13c-3a1xb12a"
```

服务器收到请求头后，会根据If-None-Match的值来判断请求的资源是否有更新。

- 如果没有更新，就返回304状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”
- 如果资源有更新，服务器就直接返回最新资源给浏览器。

简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS数据也被浏览器缓存了，这又省去了DNS查询环节

#### \14) 登录状态是如何保持的？

- 通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。
- 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用POST方法提交用户登录信息给服务器。
- 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的`Set-Cookie`字段里，如下所示，然后把响应头发送给浏览器

```text
Set-Cookie: UID=3431uad;
```

- 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有Set-Cookie字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。
- 当用户再次访问时，浏览器会发起HTTP请求，但在发起请求之前，浏览器会读取之前保存的Cookie数据，并把数据写进请求头里的Cookie字段里（如下所示），然后浏览器再将请求头发送给服务器。

```text
Cookie: UID=3431uad;
```

- 服务器在收到HTTP请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。
- 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了

好了，通过这个流程你可以知道浏览器页面状态是通过使用Cookie来实现的。Cookie流程可以参考下图：

![img](https://static001.geekbang.org/resource/image/d9/b3/d9d6cefe8d3d6d84a37a626687c6ecb3.png)

简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

###  6. 数据结构 

 \1) 栈、队列（★★★★★）  

 \2) [链表]()、顺序表（★★★★） 

 \3) 模式匹配（★★） 

 \4) 几种特殊[二叉树]()的定义及遍历方式（★★★★★） 

 \5) 图、最小生成树（★★★） 

 \6) [排序]()[算法]()（★★★★★） 

 \7) 查找（★★★） 

 \8) Hash表（★★★★） 

 \9) B树、B+树、[红黑树]()的区别（★） 

###  7. 操作系统 

####  \1) 线程与进程的区别，各自之间如何通信（★★★★★） 

​	**线程与进程的区别**：

​		1）调度的基本单位：线程作为调度的基本单位。同进程中线程切换不引起进程切换，当不同进程的线程切换才引起进程切换；进程是资源分配的基本单位。

​		2）并发性：一个进程间的多个线程可并发

​		3）拥有资源：线程仅拥有隶属进程的资源；进程是拥有资源的独立单位。

​		4）独立性：进程拥有独立的空间和私有资源；同一个进程的线程之间共享进程的地址空间和资源。

​		5）系统开销：进程大线程小

​		6）支持多处理机系统：传统进程仅能运行在一个处理机上，多线程可运行在多处理机上。

​	**进程之间的通信：**

​		1）共享存储：低级方式：基于数据结构的共享； 高级方式：基于存储区的共享

​		2）管道通信：利用一种特殊的pipe文件连接两个进程

​		3） 消息传递：直接通信方式：直接把消息挂载到接收进程的消息队列； 间接通信方式：挂到某个中间实体，接收进程找实体接受消息

​		4） 客户端和服务器：通过套接字或者远程过程调用

​	**线程之间的通信**：

​	 	1）互斥锁（mutext）和条件变量配合使用

​		 2）信号量机制：私有信号量：线程可以利用私有信号量来实现同一进程中各线程之间的同步；  公有信号量：实现不同进程间或者不同进程中各线程之间的									同步。

####  \2) 虚拟内存和物理内存（★★★） 

​		物理内存指通过物理内存条而获得的内存空间，称为RAM。而虚拟内存则是指将硬盘的一块区域划分来作为内存。虚拟内存主要作用是在计算机运行时为操作系统和各种程序提供临时储存。当物理内存不足时，可以用虚拟内存代替。

​		**虚拟内存的特征：**

​			1）多次性：一个作业被分成多次调入内存运行

​			2）对换性：允许在作业的运行过程中进行换进、换出

​			3）虚拟性：能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量

​		**虚拟内存的实现**建立在**离散分配**的存储管理方式基础上。

​		**主要实现方式**：请求分页系统和请求分段系统

####  \3) 死锁，如何解决（★★★） 

​		**死锁：**多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不再向前推进。

​		**产生死锁的必要条件：**

​			1）互斥：进程对所分配到的资源进行排它性的使用

​			2）请求和保持：进程已经至少保持了一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有

​			3）不可抢占：进程已获得的资源在未使用完之前不能被剥夺

​			4）循环等待：在发生死锁时，必然存在一个进程---资源循环等待的环形链

​		 **处理死锁的方法**：

​			1）预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止发生死锁。

​			2）避免死锁：不采用各种限制措施去破坏产生死锁的必要条件，防止系统进入不安全状态，只需在事先加以较弱的限制条件。

​			3）检测与解除死锁：允许系统在运行过程中发生死锁。一旦检测到死锁，常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配												给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。

###  8. 信息安全 

####  \1) HTTPS（★★★★★） 

​		在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

####  \2) SQL注入、DOS/DDOS、XSS、CSRF的原理及防范（★★★★） 

[前端安全系列一（XSS、CSRF） - 掘金 (juejin.cn)](https://juejin.cn/post/6844904090019840007)

[前端安全系列二（DNS劫持、SQL注入、DDOS攻击、点击劫持） - 掘金 (juejin.cn)](https://juejin.cn/post/6844904090804174861)



###  9. 其他 

####  \1) git有关操作和使用（★★★） 

```
git branch 查看本地所有分支
git status 查看当前状态 
git commit 提交 
git branch -a 查看所有的分支
git branch -r 查看远程所有分支
git commit -am "init" 提交并且加注释 
git remote add origin git@192.168.1.119:ndshow
git push origin master 将文件给推到服务器上 
git remote show origin 显示远程库origin里的资源 
git push origin master:develop
git push origin master:hb-dev 将本地库与服务器上的库进行关联 
git checkout --track origin/dev 切换到远程dev分支
git branch -D master develop 删除本地库develop
git checkout -b dev 建立一个新的本地分支dev
git merge origin/dev 将分支dev与当前分支进行合并
git checkout dev 切换到本地dev分支
git remote show 查看远程库
git add .
git rm 文件名(包括路径) 从git中删除指定文件
git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来
git config --list 看所有用户
git ls-files 看已经被提交的
git rm [file name] 删除一个文件
git commit -a 提交当前repos的所有的改变
git add [file name] 添加一个文件到git index
git commit -v 当你用－v参数的时候可以看commit的差异
git commit -m "This is the message describing the commit" 添加commit信息
git commit -a -a是代表add，把所有的change加到git index里然后再commit
git commit -a -v 一般提交命令
git log 看你commit的日志
git diff 查看尚未暂存的更新
git rm a.a 移除文件(从暂存区和工作区中删除)
git rm --cached a.a 移除文件(只从暂存区中删除)
git commit -m "remove" 移除文件(从Git中删除)
git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)
git diff --cached 或 $ git diff --staged 查看尚未提交的更新
git stash push 将文件给push到一个临时空间中
git stash pop 将文件从临时空间pop下来

//  我是cv的自取吧
```

####  \2) webpack有关使用（★★★★） 

**Loader和Plugin 有什么区别**

```
  Loader：直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。   Plugin：直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
```

####  \3) node.js有关使用（★★★★） 

####  \4) 浏览器引擎、渲染机制（★★★★★） 

  **V8引擎**：

​       **1）V8 依据 JavaScript 代码生成 AST（抽象语法树） 和执行上下文**：生成AST：**第一阶段是分词（tokenize），又称为词法分析**，其作用是将一行行的源码			拆解成一个个 token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。

​			**第二阶段是解析（parse），又称为语法分析**，其作用是将上一步生成的 token 数据+，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

​		**2）基于 AST 生成字节码，然后通过解释器（Ignition）执行字节码，通过编译器（ TurboFan）来优化编译字节码**：在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

​		字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

​	**渲染步骤：**

​       当浏览器进程获取到 HTML 的第一个字节开始，会通知渲染进程开始解析 HTML，将 HTML 转换成 DOM 树，并进入渲染流程。一般所有的浏览器都会经过五大步骤，分别是：

1. **PARSE：解析 HTML，构建 DOM 树。**
2. **STYLE：为每个节点计算最终的有效样式。****
3. **LAYOUT：为每个节点计算位置和大小等布局信息。**
4. **PAINT：绘制不同的盒子，为了避免不必要的重绘，将会分成多个层进行处理。**
5. **COMPOSITE & RENDER：将上述不同的层合成为一张位图，发送给 GPU，渲染到屏幕上。**

为了提高浏览器的渲染性能，通常的手段是保证渲染流程不被阻塞，避免不必要的绘制计算和重排重绘，利用 GPU 硬件加速等技术来提高渲染性能。

**引起重排/重绘的常见操作**

1. 外观有变化时，会导致**重绘**。相关的样式属性如 `color` `opacity` 等。
2. 布局结构或节点内容变化时，会导致**重排**
3. 获取布局信息时，会导致**重排**。相关的方法属性如 `offsetTop` `getComputedStyle` 等。

**解决方案**

1. **对 DOM 进行批量写入和读取**（通过虚拟 DOM 或者 DocumentFragment 实现）。
2. **避免对样式频繁操作，**了解常用样式属性触发 Layout / Paint / Composite 的[机制](https://csstriggers.com/)，**合理使用样式。**
3. **合理利用特殊样式属性**（如 transform: translateZ(0) 或者 will-change），**将渲染层提升为合成层，开启 GPU 加速，提高页面性能。**
4. **使用变量对布局信息（如 clientTop）进行缓存，避免因频繁读取布局信息而触发重排和重绘**。

另外，可以借助 DevTools Performance 面板来查看产生重排重绘任务占用主线程的情况和调用代码。

####  \5) 前后端分离（★★★） 

####  \6) SPA、SEO、CSR、SSR有关使用（★★） 

**SPA(单页面程序)**

 优点：

​      1.用户体验好，不刷新，减少 请求  数据ajax异步获取 页面流程；

​      2.前后端分离

​      3.减轻服务端压力

​      4.共用一套后端程序代码，适配多端

  缺点：

​    1.首屏加载过慢；

​     2.SEO 不利于搜索引擎抓取

 \7) gif、jpg、png、svg、webp等图片类型的区别和使用场景（★★） 

 \8) base64等编码的意义和使用场景（★） 

 \9) PKI体系，CA，数字签名，对称、非对称加密[算法]()等密码学知识（★） 

###  手写题目： 

####  \1) instanceof（★★★） 

```
function myInstanceof(obj,className){
	let pointer=obj //指针指向obj
	while(pointer){
		if(pointer===className.prototype){ //判断是否在原型上
			return true
		}
		pointer=pointer.__proto__ //不在继续利用__proto__去指向下一个原型查找
	}
	return false
}
```

####  \2) promise.all/race（★★★★★） 

​	**promise.all**

```
Promise.myall=function(promises){
	let arr=[]
	let count=0
	return new Promise((resolve,reject)=>{
		promises.forEach((item,i)=>{ //先循环
			Promise.resolve(item).then(res=>{  //将promises里面的每一项包装成promise对象 
				count++
				arr[i]=res
				if(count===promises.length) resolve(arr)
			},reject)
		})
	
	})
}
```

​	**promise.race**

```
Promise.myrace=function(promises){
	return new Promise((resolve,reject)=>{
		for(let item of promises){
			Promise.resolve(item).then(resolve,reject)
		}
	})
}
```

####  **\3) new（★★★）** 

```
const newMethod = ()=>{
	let constructor=[].shift.call(arguments)
	let obj={}
	obj.__proto__=constructor.prototype
	let res = constructor.apply(obj,arguments)
	return typeof res==='obj'?res:obj
	
}
```

​	

####  **\4) filter/indexOf/forEach/map/reduce（★★★★）** 

`function forEach(array, iteratee) {`
    `let index = -1;`
    `const length = array.length;`
    `while (++index < length) {`
        `iteratee(array[index], index);`
    `}`
    `return array;`
`}`

####  \5) call/apply/bind（★★★★） 

1 call

```
Fuction.prototype.mycall=function(context,...args){
	context=context||window
	args=args?args:[]
	let key = Symbol()
	context[key]=this
	let res=context[key](...args)
	delete context[key]
	return res 
	
}
```

2 apply

```
Fuction.prototype.myapply=function(context,args){
	context = context || window
	args = args?args:[]
	let key =Symbol()
	context[key] = this
	let res = context[key](...args)
	delete context[key]
	return res
}
```

3 bind

```
Function.prototype.mybind=function(context,...args){
	let fn = this
	args=args?args:[]
	return function newFun(...newArgs){
		if(this instanceof newFun){
			return fn(...args,...newArgs)
		}
		return fn.apply(context,[...args,newArgs])
	}
}
```



####  **\6) 节流/防抖（★★★★★）** 

​	**节流:** 一段时间内只执行一次

```
const throttle=(fn,delay)=>{
	let time=0
	return function(){
		let newTime=Date.now()
		if(newTime - time > delay){
			let args=arguments
			fn.apply(this,args)
			time=newTime
		}
	}
}
```

 **防抖：**一段时间内执行最后一次

```
const debounce=(fn,wait)=>{
	let timer=null
	return function(){
		clearTimeout(timer)
		let args=arguments
		timer=setTimeout(()=>{
			fn.apply(this,args)
		},wait)
	}
}
```

#### \7) 快排、冒泡、堆、归并、直插等[排序]()[算法]()（★★★★★） 

####  \8)观察者模式和 发布订阅模式（★★） 

**观察者模式：****观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。

**发布订阅模式：**订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。

**观察者模式**

```
class Subject{//被观察者
	constructor(name){
		this.name=name
		this.observers=[] 
		this.state="开心"  //状态
	}
	attach(observer){
		this.observers.push(observer)  //存放观察者实例对象
	}
	setState(newState){
		this.state=newState 
		this.observers.forEach(observer=>{
			observer.update(state) //改变状态通知观察者实例对象
		})
	}
}
class Observer{
	constructor(name){
		this.name=name
	}
	update(newState){
		console.log("通知"+this.name+"宝宝状态变为"+newState) //获取到状态更新打印
	}
}
let ob1=new Observer("爸爸")
let ob2=new Observer("妈妈")
let sub=new Subject()
sub.attach(ob1)
sub.attach(ob2)
sub.setState("不开心")

```

**发布订阅者模式**

```
let bus={
	list:[], //存储订阅者的回调函数
	subscribe(callback){
		this.list.push(callback) 将订阅者的回调函数加入list
	},
	publish(text){
		this.list.forEach((callback)=>{ //循环遍历并执行订阅者回调函数，往里传值
			callback&&callback(text)
		})
	}
}
bus.subscribe((text)=>{
	console.log('我aaa订阅了',text) //接收 发布者传来的值
})
bus.subscribe((text)=>{
	console.log('我bbb订阅了',text)
})
bus.publish("发布内容") 
```

![image-20220405185718151](.\typora-user-images\image-20220405185718151.png)

 \9) 其他变成题目(参考LeetCode、CodeTop、[牛客]())

​	**递归求阶乘 1*2...n**
​	`function fn(n){
​		if(n===1){
​		 return 1
​		}
​		return n*fn(n-1)
​	}`

`简写
​	let fn=(n)=>{
​		return n===1?1:n*fn(n-1)
​	}
​	console.log(fn(3))`

**求斐波那契数列 (兔子序列)** 1 1 2 3 5 8 13 21

`function fb(n){`

​    `if(n===1||n===2) return 1`

​	`return fb(n-1) +fb(n-2)`

`}`

####  \10) 深拷贝

```
function deepClone(obj,hash=new weakMap()){
	if(obj===null)return obj
	if(obj instanceof Date) return new Date(obj)
	if(obj instanceof RegExp) return new RegExp(obj)
	if( typeof obj !=='object' ) return obj
	if(hash.get(obj)) return hash.get(obj) //weakMap 解决对象循环引用
	let cloneObj=new obj.constructor()
	hash.set(obj,cloneObj)
	for(let key in obj){
		if(obj.hasOwnProperty(key)){
			cloneObj[key]=deepClone(obj[key],hash)
		}
	}
	return cloneObj
}
```

#### \11) Object.create()

```
function create(obj){
	if(obj===null||typeof obj !=='object'){
		throw new TypeError('输入的不是对象')
	}
	function Fun(){}
	Fun.prototype=obj
	return Fun()
}
```



## 01. 深度优先遍历(DFS) 和 广度优先遍历(BFS)

> 面试题:
>
> ​	给定一个二叉树，使用 DFS 和 BFS 遍历返回所有节点。 

#### 深度优先遍历（DFS）

![DFS](https://tva1.sinaimg.cn/large/e6c9d24ely1h0we46up81j20dm085jrs.jpg)

- DFS 的思想是从上至下，对每一个分支一直往下一层遍历直到这个分支结束，然后返回上一层，对上一层的右子树这个分支继续深搜，直到一整棵树完全遍历，因此符合栈**后进先出**的特点
- 深度优先遍历常用的数据结构是**栈**
- DFS 特性 : 不全部保留结点，占用空间少;有回溯操作(即有入栈、出栈操作)，运行速度慢。

#### 广度优先遍历（BFS）

![image-20220414221724495](.\typora-user-images\image-20220414221724495.png)

- BFS 的思想是从左至右，对树的每一层所有结点依次遍历，当一层的结点遍历完全后，对下一层开始遍历，而下一层结点又恰好是上一层的子结点。因此符合队**列先进先出**的特点

- 广度优先遍历常用的数据结构为队列

- BFS 的特性 : 保留全部结点，占用空间大;无回溯操作(即无入栈、出栈操作)，运行速度快。 

- ```
  // 深度优先遍历 DFS 栈
    //  从根出发，尽可能深的搜索树的节点
    //  技巧：
    //   1 访问根节点
    //   2 对根节点的children挨个进行深度优先遍历
  // 广度优先遍历 BFS队列
    // 从根出发优先访问离根节点最近的节点
    // 技巧
      // 1. 新建一个队列，把根节点入队
      // 2. 把队头出队
      // 3. 把队头的children挨个入队
      // 4. 重复2和3步，直到队列为空位置
  
  const tree ={
    val:'a',
    children:[
      {
        val:'b',
        children:[
          {
            val:'d',children:[]
          },
          {
            val:'e',children:[]
          },
          
        ]
      },
      {
        val:'c', 
        children:[
          {
            val:'f',children:[]
          },
          {
            val:'g',children:[]
          }
        ]
      },
    ]
  }
  const DFS=(root)=>{
    console.log(root.val);
    root.children.forEach(DFS) //循环 递归执行dfc函数
  }
  DFS(tree)
  const BFS=(root)=>{
    let arr=[root] //对象存到数组中，相当于队列
    while(arr.length>0){ //循环弹出第一个对象
      const o =arr.shift() //弹出第一个对象
      console.log(o.val); //打印对象的值
      o.children.forEach(item=>{ //循环遍历对象的children，把对象push进数组排队
        arr.push(item)
      })
    }
  }
  BFS(tree)
  ```

  

作者：三草
链接：https://www.nowcoder.com/discuss/637450?channel=-1&source_id=profile_follow_post_nctrack
来源：牛客网



### 计算机网络

> 个人觉得网络相关知识是基础中最重要的一个part，我是看书学习的（**图解HTTP**，好书，强推）

1. 浏览器从输入url到渲染完成整个过程（几乎每面必问） 
2. 五层协议、七层协议，TCP/IP 
3. HTTP状态码 

- 1XX，2XX，3XX，4XX，5XX分别代表什么，并分别举例一个状态码 
- 204，304 
- 什么是客户端错误，有遇到过吗；什么是服务端错误，开发过程中遇到过吗 

1. HTTP各版本（尤其HTTP1.1 vs HTTP2.0） 
2. HTTP请求头、响应头字段 
3. 网络攻击 
4. Cookie、Session、JWT 
5. HTTPS如何实现加密 
6. 跨域 

### JavaScript

1. 数据类型（几乎一面必问） 
2. 事件循环（宏任务有哪些、微任务有哪些）：[这篇](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly)，一定要看，讲得很好，代码举例讲解的方式 
3. 继承-原型链：[这篇](https://github.com/mqyqingfeng/Blog/issues/16) 
4. 异步 
5. ES6新特性 
6. 深浅拷贝 
7. 闭包（原理，应用：防抖、节流...) 
8. 垃圾回收机制 
9. 前端模块化 

### CSS

1. 布局（要自己去尝试写一下） 

- 左边固定宽度，右边自适应布局 
- 两栏布局、三栏布局 
- 垂直水平居中布局 

1. 选择器及优先级
2. BFC

### 框架React & Vue

#### 1.React vs Vue（简历上两个都写了，必问问题）：[参考链接](http://www.yangyong.xyz/2019/07/29/react-vs-vue/)，这篇写得非常好 

**相同点**

- 都有组件化思想
- 都支持服务器端渲染
- 都有Virtual DOM（虚拟dom）
- 数据驱动视图
- 都有支持native的方案：`Vue`的`weex`、`React`的`React native`
- 都有自己的构建工具：`Vue`的`vue-cli`、`React`的`Create React App`

**区别**

- **数据流向的不同**。`react`从诞生开始就推崇单向数据流，而`Vue`是双向数据流
- **数据变化的实现原理不同**。`react`使用的是不可变数据，而`Vue`使用的是可变的数据
- **组件化通信的不同**。**`react`中我们通过使用回调函数来进行通信的**，而`Vue`中子组件向父组件传递消息有两种方式：**事件和回调函数**
- **diff算法不同**。**`react`主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。`Vue` 使用双向指针，边对比，边更新DOM**



1. **Vue双向绑定** 
3. **组件间传值方式** 

同学们有任何疑问都欢迎提



剑指前端模拟试题

[浏览器跨域 | HZFE - 剑指前端 Offer](http://febook.hzfe.org/awesome-interview/book1/browser-cross-origin)

面试宝典

[【前端工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网 (nowcoder.com)](https://www.nowcoder.com/issue/tutorial?tutorialId=96&uuid=4700c6f1f3334c9191a38406002efa65)

剑指offer刷题

[力扣 (leetcode-cn.com)](https://leetcode-cn.com/problem-list/xb9nqhhg/)

#### 模块化的好处：

​	大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。  

​	在 ES6 模块化规范诞生之前，JavaScript 社区已经尝试并提出了 **AMD、CMD、CommonJS** 等模块化规范。
但是，这些由社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化
标准，例如：
⚫ AMD 和 CMD 适用于**浏览器端**的 Javascript 模块化
⚫ CommonJS 适用于**服务器端**的 Javascript 模块化
太多的模块化规范给开发者增加了学习的难度与开发的成本。因此，大一统的 ES6 模块化规范诞生了！  

### 字节面试一面（2022-4-18） 

cookie 有跨域可以用不

span标签可以设置大小吗 margin

跨域问题 同源策略 

jsonp原理

浏览器缓存

强缓存 协商缓存 请求头

路由形式

0.1+0.2

手写promise all

```
function Foo(){
	getName=function(){
		alert(1)
	}
	return this
}
Foo.getName=function(){alert(2)}
Foo.prototype.getName()=function(){alert(3)}
var getName=function(){alert(4)}
function getName(){alert(5)}

Foo.getName()
getName()
Foo().getName()
getName()
new Foo.getName()
```





